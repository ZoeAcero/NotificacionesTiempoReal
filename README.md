https://github.com/ZoeAcero/NotificacionesTiempoReal.git



 Proyecto: Notificaciones Reactivas en Tiempo Real (Spring WebFlux + SSE)Este proyecto implementa un sistema de notificaciones web en tiempo real utilizando el paradigma de programaci贸n reactiva de Spring Boot, Server-Sent Events (SSE) para el push continuo de datos, y MongoDB para la persistencia.1.  Fundamento Te贸rico: Patrones de Dise帽o ReactivosLa programaci贸n reactiva se centra en la gesti贸n de flujos de datos as铆ncronos mediante el uso de operadores y la no-bloqueante del procesamiento. El dise帽o de este proyecto se basa en los patrones fundamentales de la especificaci贸n Reactive Streams (adoptada por Project Reactor).1.1. Principales Patrones UtilizadosPatr贸nDescripci贸nImplementaci贸n en el C贸digoPublisher (Editor)La fuente de datos que emite eventos (datos, errores o una se帽al de finalizaci贸n).En Spring WebFlux, el Flux<T> (cero a N elementos) y el Mono<T> (cero o un elemento) son los Publishers. Nuestro NotificacionService retorna Flux<Notificacion>.Subscriber (Suscriptor)La parte que consume los datos.El objeto EventSource de JavaScript, en el navegador, act煤a como Subscriber que espera datos.Backpressure (Contrapresi贸n)Mecanismo para que el Subscriber le indique al Publisher cu谩nto puede enviar, previniendo el desborde.Usamos Sinks.many().multicast().onBackpressureBuffer() en el servicio, definiendo c贸mo manejar la situaci贸n si el suscriptor es lento.Server-Sent Events (SSE)Est谩ndar web que permite al servidor enviar datos continuamente al cliente a trav茅s de una conexi贸n HTTP abierta.El NotificacionController usa produces = MediaType.TEXT_EVENT_STREAM_VALUE para tratar el Flux como un flujo de eventos persistente.1.2. Implementaci贸n de Flujos (Mono y Flux)En el c贸digo, la composici贸n de flujos permite gestionar las operaciones as铆ncronas:Mono<Notificacion> addNotificacion(...): Define una operaci贸n que resultar谩 en un solo objeto (la notificaci贸n guardada).Flux<Notificacion> getNotificacionesEnTiempoReal(...): Este m茅todo combina dos flujos esenciales:Flujo Hist贸rico: repository.findByUsuarioOrderByFechaDesc(usuario) (finito, datos antiguos).Flujo Continuo: sink.asFlux().filter(...) (infinito, nuevos datos).Composici贸n: Usamos el operador .concatWith() para unir el flujo hist贸rico con el flujo continuo, asegurando que el cliente reciba primero los datos antiguos y luego los nuevos en tiempo real. Tambi茅n usamos .doOnSuccess() para ejecutar la emisi贸n al Sink despu茅s de que la operaci贸n de guardado as铆ncrona (repository.save()) haya finalizado con 茅xito.2. 锔 Explicaci贸n Detallada del Proyecto2.1. Capa de Persistencia (MongoDB Reactivo)Notificacion.java (Modelo): Entidad POJO marcada con @Document para mapear los objetos a la colecci贸n notificaciones.NotificacionRepository.java (Repositorio): Interfaz que extiende ReactiveMongoRepository, proporcionando los m茅todos reactivos (Mono/Flux) de acceso a datos y utilizando el mecanismo de Query Derivation (ej. findByUsuarioOrderByFechaDesc).2.2. Capa de Servicio (NotificacionService.java)Esta capa es el motor de la l贸gica de negocio y la fuente de la programaci贸n en tiempo real:Sinks.Many<Notificacion> sink: Es el punto de emisi贸n central. Todas las notificaciones nuevas o actualizadas (como marcar le铆da) se inyectan en este sink llamando a sink.tryEmitNext(notificacion).Generaci贸n Autom谩tica (@PostConstruct): Para la demostraci贸n, el m茅todo iniciarGeneracionAutomatica() utiliza Flux.interval(Duration.ofSeconds(5)) para crear un timer reactivo. Cada 5 segundos, se genera una notificaci贸n aleatoria, se guarda en MongoDB, y se emite al sink.Conexi贸n SSE: El m茅todo getNotificacionesEnTiempoReal() fusiona el flujo de notificaciones hist贸ricas con el flujo continuo del sink para proveer un 煤nico flujo ininterrumpido al controlador.2.3. Capa de Controlador (NotificacionController.java)Endpoint SSE (/notificaciones/stream/{usuario}): Este m茅todo es la interfaz HTTP del patr贸n Publisher. Al retornar un Flux<Notificacion> y usar produces = MediaType.TEXT_EVENT_STREAM_VALUE, Spring WebFlux mantiene la conexi贸n abierta y transmite cada evento que recibe del servicio.Endpoints CRUD/API: Maneja las operaciones est谩ndar (Crear, Marcar Le铆do, Eliminar) llamando al Servicio, asegurando que las operaciones que modifican la base de datos (como marcarLeido) tambi茅n emitan una actualizaci贸n al sink para que los clientes vean el cambio instant谩neamente.2.4. Frontend (Thymeleaf y SSE JavaScript)notificaciones.html: La plantilla usa Thymeleaf solo para pasar el nombre de usuario (usuario1) al JavaScript inicial.new EventSource(...): El c贸digo JavaScript abre la conexi贸n al endpoint SSE del controlador.Actualizaci贸n del DOM: La funci贸n eventSource.onmessage se activa con cada evento (notificaci贸n). El c贸digo procesa el JSON recibido y utiliza JavaScript DOM (tablaBody.insertRow(0)) para insertar o actualizar la fila de la tabla sin requerir una recarga completa de la p谩gina.
